<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Jarvis system monitor</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="http://bootswatch.com/yeti/bootstrap.css">
    <link rel="stylesheet" href="stylesheets/jarvis.css">
    <link rel="stylesheet" href="http://bootswatch.com/assets/css/bootswatch.min.css">
    <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
    <style type="text/css">
        footer {
            font-size: 12px;
        }

        #minibugs_modal_btn {
            display: none;
        }

    </style>
</head>
<body>
<div class="navbar navbar-default navbar-fixed-top">
    <div class="container">
        <div class="navbar-header">
            <a href="/" class="navbar-brand">Jarvis</i></a>
            <button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#navbar-main">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
        </div>


        <!--div class="navbar-collapse collapse" id="navbar-main">
            <div class="navbar-form navbar-right" role="search">

                <a href="{% url 'minibugs_create' %}" class="btn btn-info "><i class="fa fa-plus"></i> New ticket</a></a>
            </div>
        </div-->
    </div>
</div>


<div class="container">
    <div class="row">
            <div class="col-lg-12">
            <img src="images/logo-alpha.png" id="main_logo">

            <h1>Jarvis <span id="arelease">(&alpha; release)</span></h1>

            <p>Jarvis is a conky / screenlets replacement.<br>The idea is to have something easier to expand and easier
                to style.</p>

            <h1>What is Jarvis</h1>

            <p>
                Jarvis is a daemon serving a JSON API to one or more clients called <em>Views</em>
                <br>
                The purposes of this project are:
            </p>
            <ul>
                <li>De-couple sources of information from the final views</li>
                <li>Simplify new themes and views creation</li>
                <li>Simplify the creation of new modules in the daemon to provide new information</li>
                <li>Reuse datas and make it easily available to multiple clients</li>
            </ul>
            <p>
            The idea is to have a listening application without GUI (aka Demon) that just returns information in a json
            format about the system (aka json restful API).
            Then some <em>Views</em> will be able to get those informations and draw them on screen.<br>
            The JSON protocol eases the creation of HTML/QML view and/or the integration with existing clients.
            </p>

            <h1>How it works</h1>

            <p>
                Once started, the deamon runs at localhost on 8080.
                There is currently no support for multiple users (aka: dynamic port) or authentication... there will be
                soon though, and it will also run on https.
                The daemon will reply to any valid json messages sent on its websocket.<br><br>
                You can try and talk to the demon opening a browser and going to the <a
                    href="https://github.com/mariosgn/jarvis-backend-node/tree/master/web_console">console page</a>
                (download the entire directory locally on your hd: it will not work online)
                You can also talk to it the terminal:
            </p>
        <pre>
$ npm install wscat
$ wscat -c ws://localhost:8080
connected (press CTRL+C to quit)
> Yeah!
< {"error":true,"error_id":"Invalid request"}
> {"module":"os","action":"ping"}
< {"module":"os","action":"ping","pong":true}
> {"module":"os","action":"getactions"}
< {"module":"os","action":"getactions","result":"ok","actions":["systeminfo","cpuinfo","ping","setperiod","getactions","listen","unlisten"]}
>
        </pre>
            <p>
            You will need wscat (and not just netcat) because this nodejs implementation uses the websocket protocol and
            only that. There will be soon the plain socket support.
            </p>

            <h1>Screenshot</h1>

            <p>
                The following screenshot is taken using a <a href="https://github.com/mariosgn/jarvis-gui-webkit">Qt/webkit</a>
                view and the <a href="https://github.com/mariosgn/jarvis-backend-node/tree/master/harmattan-like-demo">Harmattan-like</a>
                demo View. This means: what you see in the screenshot is done in HTML and Javascript.
            </p>
            <p>
                <a href="images/shot-big.png"><img src="images/shot-small.png"></a>
            </p>


            <h1>Modules</h1>

            <p>
                Features and information has been grouped in <em>modules</em>.<br>
                There are few implemented modules in the nodejs daemon: </p>
            <ul>
                <li>Core</li>
                <li>Forecast</li>
                <li>Process</li>
            </ul>
            <p>Other are planned: </p>
            <ul>
                <li>I3 status</li>
                <li>Network</li>
                <li>Disk statistics and usage</li>
            </ul>
            <p>Hopefully many more...
            </p>

            <h1>Why not...</h1>

            <p>
                <strong>Q: </strong> Why another daemon just to proxy some already available information?<br>
                <strong>A: </strong> Because those information are not really available to all kind of clients (HTML)
                and .
            </p>

            <p>
                <strong>Q: </strong> Why json over dbus?<br>
                <strong>A: </strong> Because json is just an API not an implementation. It would be really complex to
                write a
                client in html talking with a dbus. And I do not actually like dbus: I like its concept and what it
                wuold do:
                not how is used/done/thought.
            </p>

            <h1>Known TODOs</h1>


            <ul>
                <li>Plain socket support</li>
                <li>Authentication</li>
                <li>Multiple instances on the same machine (multiuser)</li>
                <li>Installation and packetization</li>
            </ul>


            <h1>API</h1>
            <a id="console_img" href="images/console.png"><img src="images/console_small.png"></a>

            <p>
                Once connected to the daemon everything is sent and received in a JSON format.<br>
                If the daemon receives something strange and not in json, it reply with an error in json format:
            </p>
<pre>
 $ wscat -c ws:localhost:8080
connected (press CTRL+C to quit)
> asd
< {"error":true,"error_id":"Invalid request"}
>
</pre>
            All the message are in this form:
<pre>
{
    "module": "core",
    "action": "ping",
    "messageid": "283672019",
}
</pre>
            <p> <em>module</em>: tells the name of module to call (core, process, forecast...)<br>
            <em>action</em>: is the actual name of the function to call in the module<br>
            Those two properties are alwais needed.<br>
            There is also an optional property:<br>
            <em>messageid</em>: the value will be sent back from the daemon in the answer. It is useful to couple a
            message from the daemon to a request from the client.
            In an async world it could always happen to receive and unexpected message while waiting to a real reply.
            </p>
            <p>
                Currently the best way to play and understand the API is to download and go with a browser to the <a
                    href="https://github.com/mariosgn/jarvis-backend-node/tree/master/web_console">console page</a>. You
                will see something like the image shown on the right.</p>

            <h1>How to write new modules</h1>

            <p>
                If you decide to extend the node harvis module, you have to inherit the <em>Module</em> class. <br>
                Ex: to create the <em>SpotifyModule</em> you will create a new file called
                <em>jarvis_module_spotify.js</em>. The file must be placed near the other: currently there is a better
                module-plugin-sistem.
            </p>
<pre>
var Module = require(__dirname+'/module');
var JarvisMessage = require(__dirname+'/jarvismessage');
var util = require('util');
var EventEmitter = require('events').EventEmitter;

function ModuleSpotify() {
    Module.call(this, "spotify");
}
util.inherits(ModuleSpotify, Module);

ModuleSpotify.prototype.Init = function (cb) {
    /*
    this is an optional init function.
    it will be called just once at the first module usage
    */
    cb(null, this);
}

ModuleSpotify.prototype.onYeah = function (msg) {
    console.log("Yeah!");
}

ModuleSpotify.prototype.onSayhello = function (message) {

    if ( !message.content.hasOwnProperty("please") ) {
        message.replyError("Invalid request: missing politeness").send();
        return;
    } else {
        data = {  {"greeting": "hello"}
        message.reply( data ).send();
    }
};

ModuleOs.prototype.timerFunction = function () {
    o = {
        "action" : "tictac"
    };
    m = new JarvisMessage(this, o );
    m.send();
    console.log("Tictac!");
};

module.exports = ModuleSpotify;

</pre>
            <p>
                How it works step by step:
            </p>
<pre>
function ModuleSpotify() {
Module.call(this, "spotify");
}
</pre>
            <p>This is important: that <em>"spotify"</em> string must match with the last part of the filename.<br>
                As soon a client sends a message with the module property set to the string "spotify", the node daemon
                try to load a file called <em>jarvis_module_spotify.js</em> and, if present, try to run its Init()
                function.
                On success, the function must call <em>cb(null, this);</em> or <em>cb("Big error");</em> in case
                something went wrong (ex: see the forecast module).
            </p>

<pre>
ModuleSpotify.prototype.onYeah = function (msg) {
    console.log("Yeah!");
}
</pre>
            <p>this function will be called when a client send a message with <em>"yeah"</em> as action:
            </p>
<pre>
{
"module": "spotify",
"action": "yeah",
"play"  : "queen",
"album" : "innuendo"
}
</pre>
            <p>Generally any <em>OnWhatever</em> function will be called when the action is equal to its name without
                the "on" part and lowercase. Note: OnYeah() is different that Onyeah() or OnYeaH().<br>
                The <em>msg</em> parameter will contain the entire client message in its <em>content</em> property: in
                this case <em>msg.content.album</em> will be "innuendo".

            </p>
<pre>
...
        message.replyError("Invalid request: missing politeness").send();
...
        message.reply( data ).send();
...
};
</pre>

            <p>
                This is how to reply to a message: just call the reply() function. The message wil be delivered to the
                caller client. The function takes an optional object that will be jsonized and attached to the message.
            </p>
<pre>
ModuleOs.prototype.timerFunction = function () {
    o = {
        "action" : "tictac"
    };
    m = new JarvisMessage(this, o );
    m.send();
    console.log("Tictac!");
};
</pre>
            <p>This function is optional: it will be called any x milliseconds by the daemon.<br>
                It is not active by default and the client must activate or change it with a message like this:</p>
<pre>
{
"module": "spotify",
"action": "setperiod",
"period": 1000
}
</pre>
            <p>
                In this case the function will also send a broadcast message. Any message sent from a module (not sent
                with the reply() function) will be delivered to all the listening <em>listening</em>.
                A <em>listening</em> client is a client who sent a message like this:</p>
<pre>
{
"module": "spotify",
"action": "listen"
}
</pre>
        <p>To be finished and improved...</p>

        <h1>Help</h1>
        <p>
            For any suggestion or question write to <a href="mailto:mario.signorino@gnufish.net">mario.signorino@gnufish.net</a>.
        </p>

        </div>
    </div>


    <footer>
        <div class="row">
            <div class="col-lg-12">

                <ul class="list-unstyled">
                    <li class="pull-right"><a href="#top">Back to top</a></li>
                    <li><a href="https://github.com/mariosgn/jarvis-backend-node">Jarvis on GitHub</a></li>
                </ul>
                <p>Made by <a href="http://www.gnufish.net" rel="nofollow">Mario Signorino</a>. Contact him at <a
                        href="mailto:mario.signorino@gnufish.net">mario.signorino@gnufish.net</a> .</p>

                <p>Code released under the <a href="http://www.gnu.org/copyleft/gpl.html">GPL License</a>.</p>

                <p>Theme based on <a href="http://getbootstrap.com" rel="nofollow">Bootstrap</a>. Icons from <a
                        href="http://fortawesome.github.io/Font-Awesome/" rel="nofollow">Font Awesome</a>. Web fonts
                    from <a href="http://www.google.com/webfonts" rel="nofollow">Google</a>.</p>

            </div>
        </div>
    </footer>


</div>


<script src="https://code.jquery.com/jquery-1.10.2.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/js/bootstrap.min.js"></script>
<script src="http://bootswatch.com/assets/js/bootswatch.js"></script>
</body>
</html>

